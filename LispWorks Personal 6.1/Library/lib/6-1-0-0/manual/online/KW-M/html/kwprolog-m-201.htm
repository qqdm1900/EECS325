<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="kwprolog-m.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
 A.12  Built-in Predicates
</TITLE>

<LINK REL="next" HREF="kwprolog-m-202.htm" TYPE="text/html">
<LINK REL="prev" HREF="kwprolog-m-200.htm" TYPE="text/html">
<LINK REL="up" HREF="kwprolog-m-168.htm" TYPE="text/html">
<LINK REL="top" HREF="kwprolog-m.htm" TYPE="text/html">
<LINK REL="contents" HREF="kwprolog-m-2.htm" TYPE="text/html">
<LINK REL="index" HREF="kwprolog-m-232.htm" TYPE="text/html">
</HEAD>
<BODY BGCOLOR="#ffffff">
<DIV CLASS="HTMLBreadCrumbs"><A HREF="../../intro.htm">All Manuals</A> &gt; <A HREF="kwprolog-m.htm">KnowledgeWorks and Prolog User Guide</A> &gt; <A HREF="kwprolog-m-168.htm">A Common Prolog</A><BR><BR>
</DIV><A HREF="kwprolog-m-202.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A><A HREF="kwprolog-m-200.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Prev BORDER=0></A><A HREF="kwprolog-m-168.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A><A HREF="kwprolog-m.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A><A HREF="kwprolog-m-2.htm"><IMG ALIGN=BOTTOM SRC=contents.gif ALT=Contents BORDER=0></A><A HREF="kwprolog-m-232.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A>
<H3 CLASS="FM1Heading-App">
<A NAME="pgfId-866849"></A>A.12  <A NAME="marker-866547"></A>Built-in Predicates</H3>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867184"></A><A NAME="marker-867183"></A>/== (?x ?y)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867186"></A>same as Prolog <CODE CLASS="Code">
&#92;==</CODE>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867189"></A><A NAME="marker-867188"></A>= (?x ?y)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867191"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867194"></A><A NAME="marker-867193"></A>=.. (?x ?y)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867196"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867199"></A><A NAME="marker-867198"></A>== (?x ?y)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867201"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867204"></A><A NAME="marker-867203"></A>@&lt; (?x ?y)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867206"></A>same as Prolog except all variables sort as identical</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867209"></A><A NAME="marker-867208"></A>@=&lt; (?x ?y)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867211"></A>ditto</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867214"></A><A NAME="marker-867213"></A>@&gt; (?x ?y</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867216"></A>ditto</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867219"></A><A NAME="marker-867218"></A>@&gt;= (?x ?y)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867221"></A>ditto</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867224"></A><A NAME="marker-867223"></A>append (?x ?y ?z)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867226"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867229"></A><A NAME="marker-867228"></A>arg (+index +term ?value)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867231"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867234"></A><A NAME="marker-867233"></A>asserta (+exp)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867236"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867239"></A><A NAME="marker-867238"></A>assertz (+exp)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867241"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867244"></A><A NAME="marker-867243"></A>atomic (?x)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867246"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867249"></A><A NAME="marker-867248"></A>bagof (?exp </P>
<P CLASS="CellCode">
<A NAME="pgfId-867250"></A>       (+goal . +ex-vars)</P>
<P CLASS="CellCode">
<A NAME="pgfId-867251"></A>       ?bag)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867253"></A>standard Prolog (unusual syntax)*</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867256"></A><A NAME="marker-867255"></A>call (+exp)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867258"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867261"></A><A NAME="marker-867260"></A>clause (+head ?tail)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867263"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867266"></A><A NAME="marker-867265"></A>debug ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867268"></A>cause debugging information to be saved for each call whether it is spied or not</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867271"></A><A NAME="marker-867270"></A>debugging ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867273"></A>display a list of all spied goals</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867276"></A><A NAME="marker-867275"></A>defdetrel </P>
<P CLASS="CellCode">
<A NAME="pgfId-867277"></A>  (+name &amp;rest +clauses)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867279"></A>define a relation and declare it to be deterministic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867282"></A><A NAME="marker-867281"></A>defgrammar </P>
<P CLASS="CellCode">
<A NAME="pgfId-867283"></A>  (+name &amp;rest +rules)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867285"></A>define a grammar rule</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867288"></A><A NAME="marker-867287"></A>defrel </P>
<P CLASS="CellCode">
<A NAME="pgfId-867289"></A>  (+name &amp;rest +clauses)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867291"></A>define a relation</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867294"></A><A NAME="marker-867293"></A>defrelmacro </P>
<P CLASS="CellCode">
<A NAME="pgfId-867295"></A>  (+name +args &amp;rest +body)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867297"></A> define a logic macro</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867300"></A><A NAME="marker-867299"></A>defrel-special-form-macro </P>
<P CLASS="CellCode">
<A NAME="pgfId-867301"></A>  (+name +args &amp;rest +body)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867303"></A>like defrelmacro but can have &amp;rest in <CODE CLASS="Code">
+args</CODE>
. Use of this form will shadow all predicates named <CODE CLASS="Code">
+name </CODE>
regardless of arity.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867306"></A><A NAME="marker-867305"></A>deterministic (+name)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867308"></A>declare the relation called <CODE CLASS="Code">
?name</CODE>
 to be deterministic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867311"></A><A NAME="marker-867310"></A>erase (+ref)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867313"></A>delete the predicate with database reference<CODE CLASS="Code">
 ?ref</CODE>
 from the database</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867316"></A><A NAME="marker-867315"></A>fail ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867318"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867321"></A><A NAME="marker-867320"></A>findall </P>
<P CLASS="CellCode">
<A NAME="pgfId-867322"></A>  (?exp +goal ?result)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867324"></A>generate all solutions to ?goal and instantiate<CODE CLASS="Code">
 ?exp</CODE>
 with the values. Return a list in <CODE CLASS="Code">
?result</CODE>
. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867327"></A><A NAME="marker-867326"></A>findallset </P>
<P CLASS="CellCode">
<A NAME="pgfId-867328"></A>  (?exp +goal ?result)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867330"></A>same as findall/3 but removes duplicates</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867333"></A><A NAME="marker-867332"></A>functor </P>
<P CLASS="CellCode">
<A NAME="pgfId-867334"></A>  (?term ?functor ?arity)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867336"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867339"></A><A NAME="marker-867338"></A>halt ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867341"></A>exit Common Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867344"></A><A NAME="marker-867343"></A>integer (?x)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867346"></A>standard Prolog </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867349"></A><A NAME="marker-867348"></A>is (?result +exp)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867351"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867354"></A><A NAME="marker-867353"></A>keysort (+in ?out)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867356"></A>standard Prolog except uses alist style cons pairs</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867359"></A><A NAME="marker-867358"></A>leash (+event-spec)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867361"></A>cause the interpreter to pause and ask for input when one of the leashed events is traced. An event-spec is one of: <CODE CLASS="Code">
(call </CODE>
exit redo fail), or a list of ports. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867364"></A><A NAME="marker-867363"></A>listing </P>
<P CLASS="CellCode">
<A NAME="pgfId-867365"></A>  (+name &amp;optional +arity)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867367"></A>display a listing of the named predicate or listings for each arity if no arity is specified</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867370"></A><A NAME="marker-867369"></A>member (?x ?y)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867372"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867375"></A><A NAME="marker-867374"></A>nodebug ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867377"></A>leave debug mode (cease saving debug info for non-spied goals)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867380"></A><A NAME="marker-867379"></A>nonvar (?x)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867382"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867385"></A><A NAME="marker-867384"></A>nospy (+args)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867387"></A>remove <CODE CLASS="Code">
+args</CODE>
 from the list of spied goals.<CODE CLASS="Code">
 </CODE>
+args may be a predicate name or a list of predicate names. Unspy all goals if <CODE CLASS="Code">
+args</CODE>
 is nil</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867390"></A><A NAME="marker-867389"></A>not (+x)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867392"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867395"></A><A NAME="marker-867394"></A>notrace ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867397"></A>turn off exhaustive tracing for debugged goals</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867400"></A><A NAME="marker-867399"></A>once (+exp)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867402"></A>satisfy <CODE CLASS="Code">
+exp</CODE>
 as a goal once, then fail on retrying even if <CODE CLASS="Code">
+exp</CODE>
 has more solutions: this can be used to make a call deterministic so that the compiler can perform last call optimization</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867405"></A><A NAME="marker-867404"></A>output-defrels </P>
<P CLASS="CellCode">
<A NAME="pgfId-867406"></A>  (+name ?defrels) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867408"></A>return a list of <CODE CLASS="Code">
defrel</CODE>
 expressions derived from the dynamic clauses associated with <CODE CLASS="Code">
?name</CODE>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867411"></A><A NAME="marker-867410"></A>read-term (?term)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867413"></A>read in a term</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867416"></A><A NAME="marker-867415"></A>recorda (+exp ?val ?ref)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867418"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867421"></A><A NAME="marker-867420"></A>recorded (+term ?val ?ref)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867423"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867426"></A><A NAME="marker-867425"></A>recordz (+exp ?val ?ref) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867428"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867431"></A><A NAME="marker-867430"></A>repeat ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867433"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867436"></A><A NAME="marker-867435"></A>retract (+clause) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867438"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867441"></A><A NAME="marker-867440"></A>setof (?exp </P>
<P CLASS="CellCode">
<A NAME="pgfId-867442"></A>       (+goal . +ex-vars)</P>
<P CLASS="CellCode">
<A NAME="pgfId-867443"></A>       ?bag)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867445"></A>standard Prolog (unusual syntax)*</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867448"></A><A NAME="marker-867447"></A>sort (+in ?out) </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867450"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867453"></A><A NAME="marker-867452"></A>spy (+args)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867455"></A> spy  <CODE CLASS="Code">
+args</CODE>
.  <CODE CLASS="Code">
+args </CODE>
may be a predicate name or a list of predicate names. If arity is not mentioned for a predicate name, predicates of all aritys with that  name are spied.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867458"></A><A NAME="marker-867457"></A>trace ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867460"></A>turn on tracing for debugged goals, also turn on debugging for the next top level goal</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867463"></A><A NAME="marker-867462"></A>translate-vars </P>
<P CLASS="CellCode">
<A NAME="pgfId-867464"></A>  (?intern ?extern)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867466"></A>translate back and forth between internal and external variable representations. Can be used to pretty up the writing of terms containing variables</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867469"></A><A NAME="marker-867468"></A>true ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867471"></A>standard Prolog</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867474"></A><A NAME="marker-867473"></A>unleash (+event-spec)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867476"></A>Undo leashing for <CODE CLASS="Code">
+event-spec. </CODE>
+event-spec may be a port or a list of ports. If <CODE CLASS="Code">
+event-spec </CODE>
is nil, all ports are unleashed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellCode">
<A NAME="pgfId-867479"></A><A NAME="marker-867478"></A>var (?x)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-867481"></A>standard Prolog</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-866850"></A>* <CODE CLASS="Code">
setof</CODE>
 and <CODE CLASS="Code">
bagof</CODE>
 in standard Prolog use a special syntax for existentially quantified variables, for example:</P>
<CODE CLASS="Code-line">
<A NAME="pgfId-866851"></A>?- setof(X, Y^foo(X,Y), Z).</CODE>
<P CLASS="Body">
<A NAME="pgfId-866852"></A>In Common Prolog, this would look like:</P>
<CODE CLASS="Code-line">
<A NAME="pgfId-866853"></A>==&gt; (setof ?x ((foo ?x ?y) ?y) ?z)</CODE>
<P CLASS="Body">
<A NAME="pgfId-866854"></A>So, a goal with no existentially quantified variables is nested in an extra set of parentheses:</P>
<CODE CLASS="Code-line">
<A NAME="pgfId-866855"></A>==&gt; (bagof ?x ((bar ?x)) ?z)</CODE>
<HR>
<P CLASS="Copyrighttext-small"><I CLASS="Italic">KnowledgeWorks and Prolog User Guide (Macintosh version) - 6 Dec 2011</I></P>
<P><A HREF="kwprolog-m-202.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A><A HREF="kwprolog-m-200.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Prev BORDER=0></A><A HREF="kwprolog-m-168.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A><A HREF="kwprolog-m.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A><A HREF="kwprolog-m-2.htm"><IMG ALIGN=BOTTOM SRC=contents.gif ALT=Contents BORDER=0></A><A HREF="kwprolog-m-232.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A>
</BODY>
</HTML>
