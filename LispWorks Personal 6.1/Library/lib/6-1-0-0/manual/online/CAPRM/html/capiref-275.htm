<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="capiref.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
 output-pane
</TITLE>

<LINK REL="next" HREF="capiref-276.htm" TYPE="text/html">
<LINK REL="prev" HREF="capiref-274.htm" TYPE="text/html">
<LINK REL="up" HREF="capiref-4.htm" TYPE="text/html">
<LINK REL="top" HREF="capiref.htm" TYPE="text/html">
<LINK REL="contents" HREF="capiref-2.htm" TYPE="text/html">
<LINK REL="index" HREF="capiref-693.htm" TYPE="text/html">
</HEAD>
<BODY BGCOLOR="#ffffff">
<DIV CLASS="HTMLBreadCrumbs"><A HREF="../../intro.htm">All Manuals</A> &gt; <A HREF="capiref.htm">CAPI Reference Manual</A> &gt; <A HREF="capiref-4.htm">1 CAPI Reference Entries</A><BR><BR>
</DIV><A HREF="capiref-276.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A><A HREF="capiref-274.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Prev BORDER=0></A><A HREF="capiref-4.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A><A HREF="capiref.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A><A HREF="capiref-2.htm"><IMG ALIGN=BOTTOM SRC=contents.gif ALT=Contents BORDER=0></A><A HREF="capiref-693.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A>
<H4 CLASS="REntry">
<A NAME="pgfId-901377"></A><A NAME="35026"></A>output<A NAME="marker-4173290"></A>-pane</H4>
<DIV>
<H5 CLASS="REntry-type">
<A NAME="pgfId-901870"></A>Class</H5>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-901378"></A>Summary</H5>
<P CLASS="RBody">
<A NAME="pgfId-901383"></A>An output pane is a pane whose display and input behavior can be controlled by the programmer.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-4173279"></A>Package</H5>
<P CLASS="RSignature">
<A NAME="pgfId-4173280"></A>capi</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-901385"></A>Superclasses</H5>
<P CLASS="RSignature">
<A NAME="pgfId-901387"></A><A HREF="capiref-449.htm#12473" CLASS="XRef">titled-object</A><BR>
<A HREF="capiref-408.htm#40919" CLASS="XRef">simple-pane</A><BR>
gp:graphics-port-mixin</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-901390"></A>Subclasses</H5>
<P CLASS="RSignature">
<A NAME="pgfId-901392"></A><A HREF="capiref-293.htm#24209" CLASS="XRef">pinboard-layout</A><BR>
<A HREF="capiref-115.htm#14465" CLASS="XRef">editor-pane</A></P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-901395"></A>Initargs</H5>
<P CLASS="RDescription-Item">
<A NAME="pgfId-901397"></A><CODE CLASS="Code">
:display-callback</CODE>
<A NAME="marker-952891"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-901902"></A>A function called to redisplay the pane.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-10065454"></A><CODE CLASS="Code">
:drawing-mode</CODE>
<A NAME="marker-10065453"></A><A NAME="marker-10065461"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-10065455"></A>A keyword controlling quality of drawing, especially anti-aliasing of text.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-10065433"></A><CODE CLASS="Code">
:graphics-options</CODE>
<A NAME="marker-10065432"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-10065434"></A>A platform-specific plist of options controlling how graphics are drawn.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-10065436"></A><CODE CLASS="Code">
:draw-with-buffer</CODE>
<A NAME="marker-10065435"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-10065437"></A>A boolean controlling whether output is buffered, on Windows and Motif.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-901398"></A><CODE CLASS="Code">
:input-model</CODE>
<A NAME="marker-7834461"></A><A NAME="marker-952892"></A></P>
<P CLASS="RDescription-C">A list of input specifications, otherwise known as a command table.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-901399"></A><CODE CLASS="Code">
:scroll-callback</CODE>
<A NAME="marker-952893"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-901903"></A>A function called when the pane is scrolled, or <CODE CLASS="Code">
nil</CODE>
. The default is <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-5672455"></A><CODE CLASS="Code">
:pane-can-scroll</CODE>
<A NAME="marker-5672454"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-5672456"></A>A generalized boolean specifying whether the pane itself is responsible for drawing into the visible area.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-3007491"></A><CODE CLASS="Code">
:focus-callback</CODE>
<A NAME="marker-3007490"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-3007492"></A>A function called when the pane gets or loses the input focus, or <CODE CLASS="Code">
nil</CODE>
. The default is <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-3014969"></A><CODE CLASS="Code">
:resize-callback</CODE>
<A NAME="marker-3014968"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-5897106"></A>A function called when the pane is resized, or <CODE CLASS="Code">
nil</CODE>
. The default is <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-5897149"></A><CODE CLASS="Code">
:create-callback</CODE>
<A NAME="marker-5897148"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-5897150"></A>A function called just after the pane is created.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-5897152"></A><CODE CLASS="Code">
:destroy-callback</CODE>
<A NAME="marker-5897151"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-5897153"></A>A function called just before the pane is destroyed.</P>
<P CLASS="RDescription">
<A NAME="pgfId-9332213"></A><CODE CLASS="Code">
:use-native-input-method</CODE>
<A NAME="marker-9333317"></A><A NAME="marker-9500288"></A><A NAME="marker-9856911"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-9333074"></A>Controls whether to use native input method to interpret keyboard input. Currently this has an effect only on GTK+.</P>
<P CLASS="RDescription">
<A NAME="pgfId-9466467"></A><CODE CLASS="Code">
:composition-callback</CODE>
<A NAME="marker-9470395"></A><A NAME="marker-9856926"></A><CODE CLASS="Code">
</CODE>
<A NAME="marker-9500290"></A></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-9466469"></A>This is called for various events related to composition, which here means composing input characters into other characters by an input method. </P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-9483477"></A>Accessors</H5>
<P CLASS="RSignature">
<A NAME="pgfId-9470473"></A><A NAME="marker-9470472"></A>output-pane-display-callback<BR>
<A NAME="marker-9470474"></A>output-pane-focus-callback<BR>
<A NAME="marker-9470475"></A>output-pane-resize-callback<BR>
<A NAME="marker-9470476"></A>output-pane-scroll-callback<BR>
<A NAME="marker-9470477"></A>output-pane-create-callback<BR>
<A NAME="marker-9470478"></A>output-pane-destroy-callback<BR>
<A NAME="marker-9470479"></A>output-pane-composition-callback<BR>
<A NAME="marker-10418151"></A>output-pane-input-model</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-9470480"></A>Readers</H5>
<P CLASS="RSignature">
<A NAME="pgfId-901408"></A><A NAME="marker-4273592"></A>output-pane-graphics-options</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-901410"></A>Description</H5>
<P CLASS="RBody">
<A NAME="pgfId-901412"></A>The class <CODE CLASS="Code">
output-pane</CODE>
 is a subclass of <CODE CLASS="Code">
gp:graphics-port-mixin</CODE>
 which means that it supports many of the graphics ports drawing operations. When the CAPI needs to redisplay a region of the output pane, the <EM CLASS="Variable">
display-callback</EM>
 gets called with the <CODE CLASS="Code">
output-pane</CODE>
 and the <EM CLASS="Variable">
x</EM>
, <EM CLASS="Variable">
y</EM>
, <EM CLASS="Variable">
width</EM>
 and <EM CLASS="Variable">
height</EM>
 of the region that needs redrawing. The <EM CLASS="Variable">
display-callback</EM>
 should then use graphics port operations to redisplay that area. To force an area to be re-displayed, use the function <A HREF="capiref-587.htm#67372" CLASS="XRef">invalidate-rectangle</A>.</P>
<P CLASS="RBody">
<A NAME="pgfId-10065529"></A><EM CLASS="Variable">
drawing-mode</EM>
<A NAME="marker-10340701"></A> should be either <CODE CLASS="Code">
:compatible</CODE>
 which causes drawing to be the same as in LispWorks 6.0, or <CODE CLASS="Code">
:quality</CODE>
 which causes all the drawing to be transformed properly, and allows control over anti-aliasing on Microsoft Windows and GTK+. The default value of <EM CLASS="Variable">
drawing-mode</EM>
 is <CODE CLASS="Code">
:quality</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-10065569"></A>For more information about <EM CLASS="Variable">
drawing-mode</EM>
, see &quot;Drawing mode and anti-aliasing&quot; in the <I CLASS="Italic">
CAPI User Guide</I>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-10065623"></A><EM CLASS="Variable">
graphics-options</EM>
 is currently only used by the Mac OS X Cocoa implementation. The single option defined is <CODE CLASS="Code">
:text-rendering</CODE>
, with allowed values:</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-10065624"></A><CODE CLASS="Code">
:glyph</CODE>
</P>
<P CLASS="RDescription-C">Draw glyphs directly using Core Graphics. This only draws characters with glyphs in the chosen font.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-10065625"></A><CODE CLASS="Code">
:atsui</CODE>
</P>
<P CLASS="RDescription-C">Draw using ATSUI APIs where possible.This is slower but can handle more characters.</P>
<P CLASS="RBody">
<A NAME="pgfId-10065626"></A>When <EM CLASS="Variable">
draw-with-buffer</EM>
 is true, display of the <CODE CLASS="Code">
output-pane</CODE>
 (that is drawing the background and calling the <EM CLASS="Variable">
display-callback</EM>
) is done by first drawing to a pixmap buffer, and then drawing from that buffer. This is useful to avoid flickering if the display is complex. The default value of <EM CLASS="Variable">
draw-with-buffer</EM>
 is <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-10065507"></A>The <EM CLASS="Variable">
input-model</EM>
 provides a means to get callbacks on <A NAME="marker-10065502"></A>m<A NAME="marker-10065503"></A>o<A NAME="marker-10065504"></A>us<A NAME="marker-10065505"></A>e<A NAME="marker-10065506"></A> and <A NAME="marker-10065508"></A>k<A NAME="marker-10065509"></A>ey<A NAME="marker-10065510"></A>board gestures. An <EM CLASS="Variable">
input-model</EM>
 is a list of mappings from gesture to callback, where each mapping is a list</P>
<CODE CLASS="RCode-line">
<A NAME="pgfId-5047171"></A>(<EM CLASS="Variable">
gesture</EM>
 <EM CLASS="Variable">
callback</EM>
 . <EM CLASS="Variable">
extra-callback-args</EM>
)</CODE>
<P CLASS="RBody">
<A NAME="pgfId-5050084"></A><EM CLASS="Variable">
gesture</EM>
 specifies the type of gesture, which can be Gesture Spec, character, button, key, command or motion.</P>
<P CLASS="RBody">
<A NAME="pgfId-5047473"></A>In a Gesture Spec mapping, <EM CLASS="Variable">
gesture</EM>
 can be simply the keyword <CODE CLASS="Code">
:gesture-spec</CODE>
, which matches any keyboard input. For specific mappings, <EM CLASS="Variable">
gesture</EM>
 is a list</P>
<P CLASS="RSignature">
<A NAME="pgfId-5047480"></A>(:gesture-spec <EM CLASS="Variable">
data</EM>
 <EM CLASS="Variable">
[modifier]*</EM>
)</P>
<P CLASS="RBody">
<A NAME="pgfId-6270837"></A>in which <EM CLASS="Variable">
data</EM>
 is a character object or an integer between 0 and <CODE CLASS="Code">
char-code-limit</CODE>
 (interpreted as the character object obtained by <CODE CLASS="Code">
code-char</CODE>
), or a keyword naming a function key, and each <EM CLASS="Variable">
modifier</EM>
 is one of the keywords <CODE CLASS="Code">
:shift</CODE>
, <CODE CLASS="Code">
:control</CODE>
 and <CODE CLASS="Code">
:meta</CODE>
. Note that the <CODE CLASS="Code">
:meta</CODE>
 modifier is received only when the keys style is <CODE CLASS="Code">
:emacs</CODE>
 (see <A HREF="capiref-193.htm#72958" CLASS="XRef">interface-keys-style</A>). </P>
<P CLASS="RBody">
<A NAME="pgfId-8600314"></A>Also <EM CLASS="Variable">
data</EM>
 can be a string which is interpreted as a Gesture Spec as if by <CODE CLASS="Code">
sys:coerce-to-gesture-spec</CODE>
. See the <I CLASS="Italic">
LispWorks User Guide and Reference Manual</I>
 for a description of this and other functions for manipulating Gesture Spec objects.</P>
<P CLASS="RBody">
<A NAME="pgfId-8925179"></A><B CLASS="Bold">
Note:</B>
 on Cocoa you cannot receive <CODE CLASS="Code">
Command</CODE>
 key gestures via Gesture Spec mapping in <EM CLASS="Variable">
input-model</EM>
. To receive <CODE CLASS="Code">
Command</CODE>
 key gestures you should add corresponding menu items with accelerators. See <A HREF="capiref-247.htm#29489" CLASS="XRef">menu-item</A> for information about accelerators.</P>
<P CLASS="RBody">
<A NAME="pgfId-5049952"></A>In a character mapping, <EM CLASS="Variable">
gesture</EM>
 can be simply the keyword <CODE CLASS="Code">
:character</CODE>
, which matches any character input. For specific mappings, <EM CLASS="Variable">
gesture</EM>
 can be a list containing a single character object <EM CLASS="Variable">
char</EM>
, or a list</P>
<P CLASS="RSignature">
<A NAME="pgfId-5049953"></A>(<EM CLASS="Variable">
char</EM>
)</P>
<P CLASS="RBody">
<A NAME="pgfId-5049949"></A><B CLASS="Bold">
Note:</B>
 where input would match both a Gesture Spec mapping and a character mapping, the Gesture Spec mapping takes precedence.</P>
<P CLASS="RBody">
<A NAME="pgfId-5049985"></A>In a button mapping, <EM CLASS="Variable">
gesture</EM>
 should be list</P>
<P CLASS="RSignature">
<A NAME="pgfId-5049986"></A>(<EM CLASS="Variable">
button</EM>
 <EM CLASS="Variable">
action</EM>
 <EM CLASS="Variable">
[modifiers]*</EM>
)</P>
<P CLASS="RBody">
<A NAME="pgfId-8600324"></A>where <EM CLASS="Variable">
button</EM>
 is one of <CODE CLASS="Code">
:button-1</CODE>
, <CODE CLASS="Code">
:button-2</CODE>
 or <CODE CLASS="Code">
:button-3</CODE>
 denoting the mouse buttons. <EM CLASS="Variable">
action</EM>
 is one of <CODE CLASS="Code">
:press</CODE>
, <CODE CLASS="Code">
:release</CODE>
, <CODE CLASS="Code">
:second-press</CODE>
, <CODE CLASS="Code">
:third-press</CODE>
, <CODE CLASS="Code">
:nth-press</CODE>
 and <CODE CLASS="Code">
:motion</CODE>
, and each <EM CLASS="Variable">
modifier</EM>
 is one of the keywords <CODE CLASS="Code">
:shift</CODE>
, <CODE CLASS="Code">
:control</CODE>
, <CODE CLASS="Code">
:meta</CODE>
 and <CODE CLASS="Code">
:hyper</CODE>
. The <CODE CLASS="Code">
:meta</CODE>
 modifier will be the <CODE CLASS="Code">
Alt</CODE>
 key on most keyboards.  On Cocoa, the <CODE CLASS="Code">
:hyper</CODE>
 modifier is interpreted as the <CODE CLASS="Code">
Command</CODE>
 key for button and motion gestures.  On Windows, the <CODE CLASS="Code">
:hyper</CODE>
 modifier is currently never generated, so gestures mappings using it will never be invoked.<CODE CLASS="Code">
:third-press</CODE>
 and <CODE CLASS="Code">
:nth-press</CODE>
 are supported only on Cocoa and Motif.</P>
<P CLASS="RBody">
<A NAME="pgfId-8600778"></A>Key mappings are intended for detecting low-level keyboard input. In a key mapping, <EM CLASS="Variable">
gesture</EM>
 should be a list</P>
<CODE CLASS="RCode-line">
<A NAME="pgfId-8615604"></A><CODE CLASS="Code">
(:key [</CODE>
<EM CLASS="Variable">
keyname</EM>
<CODE CLASS="Code">
] </CODE>
<EM CLASS="Variable">
action</EM>
<CODE CLASS="Code">
 [</CODE>
<EM CLASS="Variable">
modifiers</EM>
<CODE CLASS="Code">
]*)</CODE>
</CODE>
<P CLASS="RBody">
<A NAME="pgfId-8615605"></A>where the optional <EM CLASS="Variable">
keyname</EM>
 is a character naming a key (no modifiers) or one of the valid Gesture Spec keywords, <EM CLASS="Variable">
action</EM>
 is one of <CODE CLASS="Code">
:press</CODE>
 or <CODE CLASS="Code">
:release</CODE>
 and each modifier is one of the keywords <CODE CLASS="Code">
:shift</CODE>
, <CODE CLASS="Code">
:control</CODE>
 and <CODE CLASS="Code">
:meta</CODE>
. The callback will receive a Gesture Spec object, with its data set to an integer ASCII code or a keyword representing the primary item on the key and its modifiers representing the set of modifiers pressed. The <CODE CLASS="Code">
:meta</CODE>
 modifier will be the <CODE CLASS="Code">
Alt</CODE>
 key on most keyboards.  On Cocoa, the <CODE CLASS="Code">
:hyper</CODE>
 modifier is interpreted as the <CODE CLASS="Code">
Command</CODE>
 key for <CODE CLASS="Code">
:key</CODE>
 input.</P>
<P CLASS="RBody">
<A NAME="pgfId-901436"></A>In a motion mapping, <EM CLASS="Variable">
gesture</EM>
 can either be defined in terms of dragging a button (in which case it is defined as a button gesture with <EM CLASS="Variable">
action</EM>
 <CODE CLASS="Code">
:motion</CODE>
), or it can be defined for motions whilst no button is down by just specifying the keyword <CODE CLASS="Code">
:motion</CODE>
 with no additional arguments. </P>
<P CLASS="RBody">
<A NAME="pgfId-2123278"></A>In a command mapping, gesture should be a command which is defined using <A HREF="capiref-68.htm#29349" CLASS="XRef">define-command</A>, and provides an alias for a gesture. The following commands are predefined: </P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-2123279"></A><CODE CLASS="Code">
:post-menu</CODE>
</P>
<P CLASS="RDescription-C"><CODE CLASS="Code">
(:button-3 :release)</CODE>
 on Microsoft Windows.</P>
<P CLASS="RDescription-C">
<A NAME="pgfId-2123325"></A><CODE CLASS="Code">
(:button-3 :press)</CODE>
 on Motif.</P>
<P CLASS="RDescription-C">
<A NAME="pgfId-3914764"></A><CODE CLASS="Code">
(:button-1 :press :control)</CODE>
 on Mac OS X.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-2123280"></A><CODE CLASS="Code">
:control-post-menu</CODE>
</P>
<P CLASS="RDescription-C"></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-2123540"></A><CODE CLASS="Code">
(:button-3 :press :control)</CODE>
 on Microsoft Windows, Motif and Mac OS X.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-2123532"></A><CODE CLASS="Code">
:keyboard-post-menu</CODE>
</P>
<P CLASS="RDescription-C"></P>
<P CLASS="RDescription-C">
<A NAME="pgfId-2123536"></A><CODE CLASS="Code">
(:gesture-spec :f10 :shift)</CODE>
 on Microsoft Windows, Motif and Mac OS X.</P>
<P CLASS="RBody">
<A NAME="pgfId-2123229"></A>Note that it is recommended you follow the style guidelines and conventions of the platform you are developing for when mapping gestures to results.</P>
<P CLASS="RBody">
<A NAME="pgfId-5050103"></A>When user input matches <EM CLASS="Variable">
gesture</EM>
, <EM CLASS="Variable">
callback</EM>
 is called with standard arguments and any <EM CLASS="Variable">
extra-callback-args</EM>
 as extra arguments. The standard arguments are the <CODE CLASS="Code">
output-pane</CODE>
, the x cursor position, the y cursor position, and in the case of Gesture Spec, character or key mappings, the input object that matched.</P>
<P CLASS="RBody">
<A NAME="pgfId-6139444"></A>Button mappings with <EM CLASS="Variable">
action</EM>
 <CODE CLASS="Code">
:press</CODE>
 are matched on the first button click, and they pass the standard arguments to their <EM CLASS="Variable">
callback</EM>
. Button mappings with <EM CLASS="Variable">
action</EM>
 <CODE CLASS="Code">
:second-press</CODE>
 and <CODE CLASS="Code">
:third-press</CODE>
 are matched on the second and third button click made in quick succession, and again they pass the standard arguments to their <EM CLASS="Variable">
callback</EM>
. Button mappings with <EM CLASS="Variable">
action</EM>
 <CODE CLASS="Code">
:nth-press</CODE>
 are matched on the <EM CLASS="Variable">
n</EM>
th button click made in quick succession when there is not a more specific match with <CODE CLASS="Code">
:press</CODE>
, <CODE CLASS="Code">
:second-press</CODE>
 or <CODE CLASS="Code">
:third-press</CODE>
. Then the integer <EM CLASS="Variable">
n</EM>
 is also passed as the fourth argument to <EM CLASS="Variable">
callback</EM>
, representing the number of times that the button has been pressed in quick succession. If there is a <CODE CLASS="Code">
:press</CODE>
, <CODE CLASS="Code">
:second-press</CODE>
 or <CODE CLASS="Code">
:third-press</CODE>
 handler then that is invoked instead of <CODE CLASS="Code">
:nth-press</CODE>
 for the corresponding number of presses.</P>
<P CLASS="RBody">
<A NAME="pgfId-6120270"></A><B CLASS="Bold">
Note:</B>
 mouse gestures with <CODE CLASS="Code">
:press</CODE>
, <CODE CLASS="Code">
:second-press</CODE>
, <CODE CLASS="Code">
:third-press</CODE>
 and <CODE CLASS="Code">
:nth-press</CODE>
 actions can each be expected to be followed by a <CODE CLASS="Code">
:release</CODE>
 action.</P>
<P CLASS="RBody">
<A NAME="pgfId-6302550"></A><B CLASS="Bold">
Note:</B>
 In some circumstances <CODE CLASS="Code">
:motion</CODE>
 events can be received even when the <CODE CLASS="Code">
output-pane</CODE>
 does not have the input focus. See window style <CODE CLASS="Code">
:motion-events-without-focus</CODE>
 under <A HREF="capiref-184.htm#30394" CLASS="XRef">interface</A> for details.</P>
<P CLASS="RBody">
<A NAME="pgfId-10572011"></A><EM CLASS="Variable">
input-model</EM>
 can be set before the pane is displayed, but changes after that are ignored.</P>
<P CLASS="RBody">
<A NAME="pgfId-10572044"></A>Also note that some built-in subclasses of <CODE CLASS="Code">
output-pane</CODE>
 specify their own <EM CLASS="Variable">
input-model</EM>
, so care should be taken when setting it. Generally an initial value supplied using the <CODE CLASS="Code">
:input-model</CODE>
 initarg will be prepended to any <EM CLASS="Variable">
input-model</EM>
 specified by the built-in subclass (so your input gestures will override matching supplied  gestures). However this is not true of <A HREF="capiref-115.htm#14465" CLASS="XRef">editor-pane</A>, where the <CODE CLASS="Code">
:input-model</CODE>
 initarg replaces the specified default <EM CLASS="Variable">
input-model</EM>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-10572013"></A><A NAME="marker-10572012"></A>If <EM CLASS="Variable">
pane-can-scroll</EM>
 is true then the pane is responsible for handling scrolling, by redrawing. It should draw into the visible area according to the scroll parameters. This is known as internal scrolling and an example is <A HREF="capiref-115.htm#14465" CLASS="XRef">editor-pane</A>. If <EM CLASS="Variable">
pane-can-scroll</EM>
 is <CODE CLASS="Code">
nil</CODE>
, then the CAPI is responsible for scrolling over the data range. The default value is <CODE CLASS="Code">
nil</CODE>
. This is known as ordinary scrolling and there is an example in <CODE CLASS="Code">
output-panes/scroll-test.lisp</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-901443"></A>When the output pane is scrolled, the CAPI calls the <CODE CLASS="Code">
</CODE>
<A NAME="scroll-callback"></A><EM CLASS="Variable">
scroll-callback</EM>
 if this is non-nil. The arguments of the scroll callback are the <CODE CLASS="Code">
output-pane,</CODE>
 the direction (<CODE CLASS="Code">
:vertical</CODE>
, <CODE CLASS="Code">
:horizontal</CODE>
 or <CODE CLASS="Code">
:pan</CODE>
), the scroll operation (<CODE CLASS="Code">
:move</CODE>
, <CODE CLASS="Code">
:drag</CODE>
, <CODE CLASS="Code">
:step</CODE>
 or <CODE CLASS="Code">
:page</CODE>
), the amount of scrolling (an integer), and a keyword argument <CODE CLASS="Code">
:interactive</CODE>
. This has value <CODE CLASS="Code">
t</CODE>
 if the scroll was invoked interactively, and value <CODE CLASS="Code">
nil</CODE>
 if the scroll was programmatic, such as via the function <A HREF="capiref-371.htm#scroll" CLASS="XRef">scroll</A>. In the Mac OS X Cocoa implementation the direction is always <CODE CLASS="Code">
:pan</CODE>
. See the following CAPI example files:</P>
<PRE CLASS="RCode-body"><A NAME="pgfId-1532968"></A>output-panes/scroll-test.lisp</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1532970"></A>output-panes/scrolling-without-bar.lisp</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1532971"></A>graphics/scrolling-test.lisp</PRE>
<P CLASS="RBody">
<A NAME="pgfId-3007511"></A><EM CLASS="Variable">
focus-callback</EM>
, if non-nil, is a function of two arguments. The first argument is the <CODE CLASS="Code">
output-pane</CODE>
 itself, and the second is a boolean. When the <CODE CLASS="Code">
output-pane</CODE>
 gets the focus, <EM CLASS="Variable">
focus-callback</EM>
 is called with second argument <CODE CLASS="Code">
t</CODE>
, and when the <CODE CLASS="Code">
output-pane</CODE>
 loses the focus, <EM CLASS="Variable">
focus-callback</EM>
 is called with second argument <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-3015035"></A><EM CLASS="Variable">
resize-callback</EM>
, if non-nil, is a function of five arguments called when the <CODE CLASS="Code">
output-pane</CODE>
 is resized. The first argument is the <CODE CLASS="Code">
output-pane</CODE>
 itself, and the rest are its new geometry: <EM CLASS="Variable">
x</EM>
, <EM CLASS="Variable">
y</EM>
, <EM CLASS="Variable">
width</EM>
 and <EM CLASS="Variable">
height</EM>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-5896118"></A><EM CLASS="Variable">
create-callback</EM>
, if non-nil, is a function of one argument which is called just after the pane is created (but before it becomes visible). The argument is the pane itself. This function can perform initialization such as loading images.</P>
<P CLASS="RBody">
<A NAME="pgfId-5896123"></A><EM CLASS="Variable">
destroy-callback</EM>
, if non-nil, is a function of one argument which is called just before the pane is destroyed, for example when the window is closed or the pane is removed from its layout. The argument is the pane itself. This function can perform cleanup operations (though note that images associated with the pane are automatically freed).</P>
<P CLASS="RBody">
<A NAME="pgfId-9334883"></A><EM CLASS="Variable">
use-native-input-method</EM>
 should be <CODE CLASS="Code">
nil</CODE>
, <CODE CLASS="Code">
t</CODE>
 or <CODE CLASS="Code">
:default</CODE>
. If <EM CLASS="Variable">
use-native-input-method</EM>
 is not supplied, or is <CODE CLASS="Code">
:default</CODE>
, the default is used, which is controlled by <A HREF="capiref-384.htm#30973" CLASS="XRef">set-default-use-native-input-method</A>. The default setting is always to use native input methods.</P>
<P CLASS="RBody">
<A NAME="pgfId-9483498"></A><EM CLASS="Variable">
composition-callback</EM>
 is a function with signature</P>
<P CLASS="RSignature">
<A NAME="pgfId-9499733"></A>composition-callback <EM CLASS="Variable">
pane</EM>
 <EM CLASS="Variable">
what</EM>
</P>
<P CLASS="RBody">
<A NAME="pgfId-9499734"></A>where <EM CLASS="Variable">
pane</EM>
 is the output pane and <EM CLASS="Variable">
what</EM>
 can be one of:</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-9483501"></A><CODE CLASS="Code">
:start</CODE>
</P>
<P CLASS="RDescription-C">The composition operation is starting.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-9483502"></A><CODE CLASS="Code">
:end</CODE>
</P>
<P CLASS="RDescription-C">The composition ends.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-9483503"></A>A list</P>
<P CLASS="RDescription-C">A plist describing the &quot;preedit&quot; string, which is a string containing the partial input that should be displayed while the composition is ongoing. These calls with a plist occur only when the underlying system does not display the partial input itself. Currently on Microsoft Windows the system always displays the preedit string itself, so these calls occur only on GTK+ and Cocoa.</P>
<P CLASS="RBody">
<A NAME="pgfId-9483504"></A>During composition there will be repeated calls with a list, in general each time that the preedit string changes. Each call is a complete description of what needs to be displayed. The data from previous calls should be ignored.</P>
<P CLASS="RBody">
<A NAME="pgfId-9483505"></A>The keys that can appear in the plist are currently:</P>
<P CLASS="RDescription">
<A NAME="pgfId-9483506"></A><CODE CLASS="Code">
:string-face-lists</CODE>
</P>
<P CLASS="RDescription-C">
<A NAME="pgfId-9499990"></A>The value is a list where each element is itself a list, where the first element is a string and the second a plist describing a face (a face plist). The strings are the strings that need to be displayed, and the face plist describing the face that the underlying GUI thinks that each string needs to be displayed. The face plist may contain any of the following keywords: <CODE CLASS="Code">
:foreground</CODE>
, <CODE CLASS="Code">
:background</CODE>
, <CODE CLASS="Code">
:font</CODE>
, <CODE CLASS="Code">
:bold-p</CODE>
, <CODE CLASS="Code">
:italic-p</CODE>
, <CODE CLASS="Code">
:underline-p</CODE>
. The argument <EM CLASS="Variable">
string-face-lists</EM>
 may be <CODE CLASS="Code">
nil</CODE>
, which means display nothing.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-9483507"></A><CODE CLASS="Code">
:cursor</CODE>
</P>
<P CLASS="RDescription-C">The argument is an integer describing where the &quot;cursor&quot; should be displayed. The index is into the string that is concatenation of the strings in <EM CLASS="Variable">
string-face-lists</EM>
. </P>
<P CLASS="RDescription">
<A NAME="pgfId-9483508"></A><CODE CLASS="Code">
:selected-range</CODE>
</P>
<P CLASS="RDescription-C">
<A NAME="pgfId-9500000"></A>If present, the value specifies the selected range as a cons of start and length in characters. The start is an index into the string that is a concatenation of the strings in the <EM CLASS="Variable">
string-face-list</EM>
.</P>
<P CLASS="RDescription">
<A NAME="pgfId-9483509"></A><CODE CLASS="Code">
:selection-needs-face</CODE>
</P>
<P CLASS="RDescription-C">
<A NAME="pgfId-9500007"></A>A boolean specifying whether the <EM CLASS="Variable">
selected-range</EM>
 should have a different face to the unselected range. </P>
<P CLASS="RBody">
<A NAME="pgfId-9500061"></A>The editor uses the <CODE CLASS="Code">
:start</CODE>
 call to position the composition window at the cursor by using <A HREF="capiref-380.htm#45806" CLASS="XRef">set-composition-placement</A> and the calls with a list to display the partial composition string. </P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-9334891"></A>Notes</H5>
<OL>
<LI CLASS="RStep-1">
<A NAME="pgfId-8482123"></A><EM CLASS="Variable">
draw-with-buffer</EM>
 is typically useful for a <A HREF="capiref-293.htm#24209" CLASS="XRef">pinboard-layout</A> with large number of pinboard objects, or any other feature that may cause it to flicker. </LI>
<LI CLASS="RStep">
<A NAME="pgfId-8482124"></A>The GTK+ and Cocoa libraries always buffer, so <EM CLASS="Variable">
draw-with-buffer</EM>
 is ignored on these platforms.</LI>
<LI CLASS="RStep">
<A NAME="pgfId-9500070"></A>In GTK+ versions before 2.12 the <CODE CLASS="Code">
:start</CODE>
 and <CODE CLASS="Code">
:end</CODE>
 calls are not reliable.</LI>
</OL>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-8481997"></A>Example</H5>
<P CLASS="RBody">
<A NAME="pgfId-8481998"></A>Firstly, here is an example that draws a circle in an output pane. </P>
<PRE CLASS="RCode-first"><A NAME="pgfId-901452"></A>(defun display-circle (self x y width height)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-901453"></A>  (declare (ignore x y width height))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-901454"></A>  (gp:draw-circle self 200 200 200 :filled t))</PRE>
<PRE CLASS="RCode-first"><A NAME="pgfId-4757681"></A>(capi:contain (make-instance</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4757682"></A>               'capi:output-pane</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4757683"></A>               :display-callback 'display-circle)</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-1138489"></A>              :best-width 200 :best-height 200)</PRE>
<P CLASS="RBody">
<A NAME="pgfId-901468"></A>Here is an example that shows how to use a button gesture. </P>
<PRE CLASS="RCode-first"><A NAME="pgfId-901470"></A>(defun test-callback (self x y)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-901471"></A>  (capi:display-message</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-901472"></A>   &quot;Pressed button 1 at (&#126;S,&#126;S) in &#126;S&quot; x y self))</PRE>
<PRE CLASS="RCode-first"><A NAME="pgfId-4769061"></A>(capi:contain </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4769062"></A> (make-instance</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4769063"></A>  'capi:output-pane</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4769064"></A>  :title &quot;Press button 1:&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4769065"></A>  :input-model `(((:button-1 :press)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4769066"></A>                  test-callback)))</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-901483"></A> :best-width 200 :best-height 200)</PRE>
<P CLASS="RBody">
<A NAME="pgfId-901487"></A>This example illustrates Gesture Spec mappings.</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-5078290"></A>(defun draw-input (self x y gspec)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078291"></A>  (let ((data (sys:gesture-spec-data gspec))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078292"></A>        (mods (sys:gesture-spec-modifiers gspec)))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078293"></A>    (gp:draw-string</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078294"></A>     self </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078295"></A>     (with-output-to-string (ss) </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078296"></A>       (sys:print-pretty-gesture-spec</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078297"></A>        gspec ss :force-shift-for-upcase nil))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078298"></A>     x y)))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078299"></A>&nbsp;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078300"></A>(capi:contain </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078301"></A> (make-instance</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078302"></A>  'capi:output-pane</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078303"></A>  :title &quot;Press keys in the pane...&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078304"></A>  :input-model '((:gesture-spec</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078305"></A>                  draw-input)))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078306"></A> :best-width 200 :best-height 200)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078307"></A>&nbsp;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078308"></A>(capi:contain </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078309"></A> (make-instance</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078310"></A>  'capi:output-pane</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078311"></A>  :title &quot;Press Control-a in the pane...&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078312"></A>  :input-model '(((:gesture-spec &quot;Control-a&quot;)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5078313"></A>                  draw-input)))</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-5062602"></A> :best-width 200 :best-height 200)</PRE>
<P CLASS="RBody">
<A NAME="pgfId-5065068"></A>Here is a simple example that draws the character typed at the cursor point. </P>
<PRE CLASS="RCode-first"><A NAME="pgfId-901489"></A>(defun draw-character (self x y character)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-901490"></A>  (gp:draw-character self character x y))</PRE>
<PRE CLASS="RCode-first"><A NAME="pgfId-4769120"></A>(capi:contain </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4769121"></A> (make-instance</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4769122"></A>  'capi:output-pane</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4769123"></A>  :title &quot;Press keys in the pane...&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4769124"></A>  :input-model '((:character draw-character)))</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-901499"></A> :best-width 200 :best-height 200)</PRE>
<P CLASS="RBody">
<A NAME="pgfId-901503"></A>This example shows how to use the motion gesture. </P>
<PRE CLASS="RCode-first"><A NAME="pgfId-5050116"></A>(defun draw-red-blob (self x y)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050117"></A>  (gp:draw-circle self x y 3 </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050118"></A>                  :filled t </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050119"></A>                  :foreground :red))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050120"></A>&nbsp;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050121"></A>(capi:contain </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050122"></A> (make-instance</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050123"></A>  'capi:output-pane</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050124"></A>  :title &quot;Drag button-1 across this pane.&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050125"></A>  :input-model '(((:button-1 :motion)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050126"></A>                  gp:draw-point)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050127"></A>                 ((:button-1 :motion :control)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-5050128"></A>                  draw-red-blob)))</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-3007804"></A> :best-width 200 :best-height 200)</PRE>
<P CLASS="RBody">
<A NAME="pgfId-4769157"></A>This example illustrates the use of <EM CLASS="Variable">
focus-callback</EM>
:</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-3013770"></A>(capi:contain </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-3013771"></A> (make-instance </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-3013772"></A>  'capi:output-pane</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-3013773"></A>  :focus-callback </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-3013774"></A>  #'(lambda (x y)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-3013775"></A>      (format t </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-3013776"></A>              &quot;Pane &#126;a &#126;:[lost&#126;;got&#126;] the focus&#126;%&quot; </PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-3013756"></A>              x y))))</PRE>
<P CLASS="RBody">
<A NAME="pgfId-4259587"></A>This example illustrates the use of <EM CLASS="Variable">
graphics-options</EM>
 to specify   ATSUI drawing on Cocoa:</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-4259637"></A>(defvar *string* </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259638"></A>  (coerce (loop for i from 0 below 60</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259639"></A>                collect (code-char (* 5 i))) </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259640"></A>          'text-string))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259641"></A>&nbsp;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259642"></A>(capi:contain </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259643"></A> (make-instance 'capi:output-pane </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259644"></A>                :visible-min-width 400 </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259645"></A>                :visible-max-height 50</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259646"></A>                :display-callback </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259647"></A>                #'(lambda (pane x y w h)  </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259648"></A>                    (gp:draw-string pane </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259649"></A>                                    *string* </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259650"></A>                                    10 10)) </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-4259651"></A>                :graphics-options </PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-4259627"></A>                '(:text-rendering :atsui)))</PRE>
<P CLASS="RBody">
<A NAME="pgfId-10268760"></A>This example illustrates some effects of <EM CLASS="Variable">
drawing-mode</EM>
:</P>
<P CLASS="RBody">
<A NAME="pgfId-10268791"></A><CODE CLASS="Code">
examples/capi/graphics/catherine-wheel.lisp</CODE>
</P>
<P CLASS="RBody">
<A NAME="pgfId-3481820"></A>There are further examples in the directory <CODE CLASS="Code">
examples/capi/output-panes/</CODE>
.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-901519"></A>See also</H5>
<P CLASS="RBody">
<A NAME="pgfId-9500090"></A><A HREF="capiref-68.htm#29349" CLASS="XRef">define-command</A> <BR>
<A HREF="capiref-294.htm#24563" CLASS="XRef">pinboard-object</A><BR>
<A HREF="capiref-371.htm#scroll" CLASS="XRef">scroll</A><BR>
<A HREF="capiref-384.htm#30973" CLASS="XRef">set-default-use-native-input-method</A><BR>
<A HREF="capiref-380.htm#45806" CLASS="XRef">set-composition-placement</A></P>
</DIV>
<HR>
<P CLASS="Copyrighttext-small"><I CLASS="Italic">CAPI Reference Manual - 15 Dec 2011</I></P>
<P><A HREF="capiref-276.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A><A HREF="capiref-274.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Prev BORDER=0></A><A HREF="capiref-4.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A><A HREF="capiref.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A><A HREF="capiref-2.htm"><IMG ALIGN=BOTTOM SRC=contents.gif ALT=Contents BORDER=0></A><A HREF="capiref-693.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A>
</BODY>
</HTML>
