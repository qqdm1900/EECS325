<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="fli.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
 define-foreign-converter
</TITLE>

<LINK REL="next" HREF="fli-92.htm" TYPE="text/html">
<LINK REL="prev" HREF="fli-90.htm" TYPE="text/html">
<LINK REL="up" HREF="fli-70.htm" TYPE="text/html">
<LINK REL="top" HREF="fli.htm" TYPE="text/html">
<LINK REL="contents" HREF="fli-2.htm" TYPE="text/html">
<LINK REL="index" HREF="fli-216.htm" TYPE="text/html">
</HEAD>
<BODY BGCOLOR="#ffffff">
<DIV CLASS="HTMLBreadCrumbs"><A HREF="../../intro.htm">All Manuals</A> &gt; <A HREF="fli.htm">LispWorks Foreign Language Interface User Guide and Reference Manual</A> &gt; <A HREF="fli-70.htm">5 Function and Macro Reference</A><BR><BR>
</DIV><A HREF="fli-92.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A><A HREF="fli-90.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Prev BORDER=0></A><A HREF="fli-70.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A><A HREF="fli.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A><A HREF="fli-2.htm"><IMG ALIGN=BOTTOM SRC=contents.gif ALT=Contents BORDER=0></A><A HREF="fli-216.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A>
<H4 CLASS="REntry">
<A NAME="pgfId-1353736"></A><A NAME="23684"></A>define-foreign-converter<A NAME="marker-1356891"></A></H4>
<DIV>
<H5 CLASS="REntry-type">
<A NAME="pgfId-1353737"></A>Macro</H5>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-1353738"></A>Summary</H5>
<P CLASS="RBody">
<A NAME="pgfId-1353739"></A>Defines a new FLI type specifier that converts to or from another type specifier.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-1353740"></A>Package</H5>
<P CLASS="RSignature">
<A NAME="pgfId-1353741"></A>fli</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-1353742"></A>Signature</H5>
<P CLASS="RSignature">
<A NAME="pgfId-1353743"></A>define-foreign-converter <EM CLASS="Variable">
type-name</EM>
 <EM CLASS="Variable">
lambda-list</EM>
 <EM CLASS="Variable">
object-names</EM>
 &amp;key <EM CLASS="Variable">
foreign-type</EM>
 <EM CLASS="Variable">
foreign-to-lisp</EM>
 <EM CLASS="Variable">
lisp-to-foreign</EM>
 <EM CLASS="Variable">
predicate</EM>
 <EM CLASS="Variable">
tested-value</EM>
 <EM CLASS="Variable">
error-form</EM>
 <EM CLASS="Variable">
documentation</EM>
 =&gt; <EM CLASS="Variable">
type-name</EM>
</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-1353744"></A>Arguments</H5>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353745"></A><EM CLASS="Variable">
type-name</EM>
</P>
<P CLASS="RDescription-C">A symbol naming the new FLI type.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353746"></A><EM CLASS="Variable">
lambda-list</EM>
</P>
<P CLASS="RDescription-C">A lambda list which is the argument list of the new FLI type.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353747"></A><EM CLASS="Variable">
object-names</EM>
</P>
<P CLASS="RDescription-C">A symbol or a list of two symbols</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353748"></A><EM CLASS="Variable">
foreign-type</EM>
</P>
<P CLASS="RDescription-C">A macroexpansion form that evaluates to a FLI type descriptor</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353749"></A><EM CLASS="Variable">
foreign-to-lisp</EM>
</P>
<P CLASS="RDescription-C">A macroexpansion form to convert between Lisp and the FLI.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353750"></A><EM CLASS="Variable">
lisp-to-foreign</EM>
</P>
<P CLASS="RDescription-C">A macroexpansion form to convert between the FLI and Lisp.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353751"></A><EM CLASS="Variable">
predicate</EM>
</P>
<P CLASS="RDescription-C">A macroexpansion form to check if a Lisp object is of this type.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353752"></A><EM CLASS="Variable">
tested-value</EM>
</P>
<P CLASS="RDescription-C">A macroexpansion form to give an error if a Lisp object is not of this type.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353753"></A><EM CLASS="Variable">
error-form</EM>
</P>
<P CLASS="RDescription-C">A macroeXpansion form to give an error if <EM CLASS="Variable">
predicate</EM>
 returns false.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353754"></A><EM CLASS="Variable">
documentation</EM>
</P>
<P CLASS="RDescription-C">A string.</P>
<P CLASS="RDescription">
<A NAME="pgfId-1353755"></A><EM CLASS="Variable">
object-names</EM>
 ::= <EM CLASS="Variable">
object-name</EM>
 | ( <EM CLASS="Variable">
lisp-object-name</EM>
 <EM CLASS="Variable">
foreign-object-name</EM>
 )</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-1353756"></A>Values</H5>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1353757"></A><EM CLASS="Variable">
type-name</EM>
</P>
<P CLASS="RDescription-C">The name of the new FLI converter type</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-1353758"></A>Description</H5>
<P CLASS="RBody">
<A NAME="pgfId-1353759"></A>Note: this macro is for advanced use of the FLI type system. See <A HREF="fli-96.htm#39541" CLASS="XRef">define-foreign-type</A> for simple aliasing of FLI type descriptors.</P>
<P CLASS="RBody">
<A NAME="pgfId-1353760"></A>The macro <CODE CLASS="Code">
define-foreign-converter</CODE>
 defines a new FLI type specifier <EM CLASS="Variable">
type-name</EM>
 that wraps another FLI type specifier and optionally performs data conversion and type checking. The string <EM CLASS="Variable">
documentation</EM>
 is associated with <EM CLASS="Variable">
type-name</EM>
 with the <A HREF="fli-96.htm#39541" CLASS="XRef">define-foreign-type</A> documentation type.</P>
<P CLASS="RBody">
<A NAME="pgfId-1353761"></A>The lambda list of the new FLI type specifier is <EM CLASS="Variable">
lambda-list</EM>
 and its variables are available for use in the <EM CLASS="Variable">
foreign-type</EM>
, <EM CLASS="Variable">
foreign-to-lisp</EM>
, <EM CLASS="Variable">
lisp-to-foreign</EM>
, <EM CLASS="Variable">
predicate</EM>
 and <EM CLASS="Variable">
tested-value</EM>
 forms.</P>
<P CLASS="RBody">
<A NAME="pgfId-1353762"></A>If <EM CLASS="Variable">
object-names</EM>
 is a symbol <EM CLASS="Variable">
object-name</EM>
, then it provides the name of a variable for use in all of the macroexpansion forms. Otherwise <EM CLASS="Variable">
object-names</EM>
 should be a list of the form (<EM CLASS="Variable">
lisp-object-name</EM>
 <EM CLASS="Variable">
foreign-object-name</EM>
), where <EM CLASS="Variable">
lisp-object-name</EM>
 provides the name of a variable for use in the <EM CLASS="Variable">
lisp-to-foreign</EM>
, <EM CLASS="Variable">
predicate</EM>
 and <EM CLASS="Variable">
tested-value</EM>
 forms and <EM CLASS="Variable">
foreign-object-name</EM>
 provides the name of a variable for use in the <EM CLASS="Variable">
foreign-to-lisp</EM>
 form.</P>
<P CLASS="RBody">
<A NAME="pgfId-1353763"></A>When the new FLI type is used, the <EM CLASS="Variable">
foreign-type</EM>
 form is evaluated to determine the underlying FLI type descriptor to be converted. It can use variables bound by <EM CLASS="Variable">
lambda-list</EM>
, but not <EM CLASS="Variable">
object-names</EM>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-1353764"></A>When <EM CLASS="Variable">
type-name</EM>
 is used to convert a foreign value to Lisp (for example when as the <EM CLASS="Variable">
result-type</EM>
 in <A HREF="fli-94.htm#27849" CLASS="XRef">define-foreign-function</A>), the <EM CLASS="Variable">
foreign-to-lisp</EM>
 form is evaluated to determine how the conversion should be made. It works like a macroexpansion function, so should return a form that converts the foreign value, which will be bound to <EM CLASS="Variable">
object-name</EM>
 (or <EM CLASS="Variable">
foreign-object-name</EM>
). It can use variables bound by <EM CLASS="Variable">
lambda-list</EM>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-1353765"></A>When <EM CLASS="Variable">
type-name</EM>
 is used to convert a Lisp value to a foreign value (for example in the argument list of <A HREF="fli-94.htm#27849" CLASS="XRef">define-foreign-function</A>), the type of the Lisp value can be checked before conversion using <EM CLASS="Variable">
tested-value</EM>
 and <EM CLASS="Variable">
predicate</EM>
 and then converted using <EM CLASS="Variable">
lisp-to-foreign</EM>
 as detailed below.</P>
<P CLASS="RBody">
<A NAME="pgfId-1353766"></A>If <EM CLASS="Variable">
tested-value</EM>
 is specified, it is used as a macroexpansion function that returns a form that must return <EM CLASS="Variable">
object-name</EM>
 (or <EM CLASS="Variable">
lisp-object-name</EM>
) if it is of the required type or give an error. It can use variables bound by <EM CLASS="Variable">
lambda-list</EM>
, but not <EM CLASS="Variable">
object-names</EM>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-1353767"></A>Otherwise, if <EM CLASS="Variable">
predicate</EM>
 is specified, it is used as a macroexpansion function that returns a form that must return true if <EM CLASS="Variable">
object-name</EM>
 (or <EM CLASS="Variable">
lisp-object-name</EM>
) is of the required type. If <EM CLASS="Variable">
predicate</EM>
 is specified, then <EM CLASS="Variable">
error-form</EM>
 can be specified as a macroexpansion function that signals an error about <EM CLASS="Variable">
object-name</EM>
 (or <EM CLASS="Variable">
lisp-object-name</EM>
) not being of the required type. If <EM CLASS="Variable">
error-form</EM>
 is omitted, a default error is signaled. Both <EM CLASS="Variable">
predicate</EM>
 and <EM CLASS="Variable">
error-form</EM>
 can use variables bound by <EM CLASS="Variable">
lambda-list</EM>
, but not <EM CLASS="Variable">
object-names</EM>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-1353768"></A>If both <EM CLASS="Variable">
tested-value</EM>
 and <EM CLASS="Variable">
predicate</EM>
 are omitted, then no type checking is performed.</P>
<P CLASS="RBody">
<A NAME="pgfId-1353769"></A>After type checking, <EM CLASS="Variable">
lisp-to-foreign</EM>
 is used as a macroexpansion function that returns a form that converts the Lisp object <EM CLASS="Variable">
object-name</EM>
 (or <EM CLASS="Variable">
lisp-object-name</EM>
) to the underlying FLI type <EM CLASS="Variable">
foreign-type</EM>
. It can use variables bound by <EM CLASS="Variable">
lambda-list</EM>
, but not <EM CLASS="Variable">
object-names</EM>
.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-1353770"></A>Examples</H5>
<P CLASS="RBody">
<A NAME="pgfId-1353771"></A>This defines a FLI type <CODE CLASS="Code">
(real-double </CODE>
<EM CLASS="Variable">
lisp-type</EM>
<CODE CLASS="Code">
)</CODE>
, which allows any real value in Lisp to be passed to foreign code as a double precision float. When a foreign value is converted to Lisp, it is coerced to <EM CLASS="Variable">
type</EM>
:</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-1356094"></A>(fli:define-foreign-converter real-double (lisp-type)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1356095"></A>    object</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1356096"></A>  :foreign-type :double</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1356097"></A>  :foreign-to-lisp `(coerce ,object ',lisp-type)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1356098"></A>  :lisp-to-foreign `(coerce ,object 'double-float)</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-1353776"></A>  :predicate `(realp ,object))</PRE>
<P CLASS="RBody">
<A NAME="pgfId-1353777"></A>This defines a FLI type <CODE CLASS="Code">
int-signum</CODE>
, which uses -1, 0 and 1 for values on the foreign side.  There is no <EM CLASS="Variable">
foreign-to-lisp</EM>
 form specified, so it will return these values to Lisp too:</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-1353778"></A>(fli:define-foreign-converter int-signum () object</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1353779"></A>  :foreign-type :int</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-1353780"></A>  :lisp-to-foreign `(signum ,object))</PRE>
<P CLASS="RBody">
<A NAME="pgfId-1353781"></A>This defines a FLI type <CODE CLASS="Code">
(bigger-in-lisp </CODE>
<EM CLASS="Variable">
n</EM>
<CODE CLASS="Code">
)</CODE>
, which is an integer type for values that are <EM CLASS="Variable">
n</EM>
 bigger in Lisp than on the foreign side.</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-1356597"></A>(fli:define-foreign-converter bigger-in-lisp</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1356598"></A>    (&amp;optional (n 1))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1356599"></A>    object</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1356600"></A>  :foreign-type :int</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1356601"></A>  :foreign-to-lisp `(+ ,object ,n)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1356602"></A>  :lisp-to-foreign `(- ,object ,n)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1353786"></A>  :predicate `(integerp ,object))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1353787"></A>&nbsp;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1353788"></A>(fli:with-dynamic-foreign-objects ((x :int 10))</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-1353789"></A>  (fli:dereference x :type '(bigger-in-lisp 2)))  =&gt;  12</PRE>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-1353790"></A>See also</H5>
<P CLASS="RBody">
<A NAME="pgfId-1566304"></A><A HREF="fli-96.htm#39541" CLASS="XRef">define-foreign-type</A><BR>
<A HREF="fli-98.htm#13472" CLASS="XRef">define-opaque-pointer</A><BR>
<A HREF="fli-200.htm#39892" CLASS="XRef">:wrapper</A><BR>
<A HREF="fli-27.htm#98645" CLASS="XRef">Parameterized types</A></P>
</DIV>
<HR>
<P CLASS="Copyrighttext-small"><I CLASS="Italic">LispWorks Foreign Language Interface User Guide and Reference Manual - 7 Dec 2011</I></P>
<P><A HREF="fli-92.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A><A HREF="fli-90.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Prev BORDER=0></A><A HREF="fli-70.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A><A HREF="fli.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A><A HREF="fli-2.htm"><IMG ALIGN=BOTTOM SRC=contents.gif ALT=Contents BORDER=0></A><A HREF="fli-216.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A>
</BODY>
</HTML>
