<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="lw.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
 select
</TITLE>

<LINK REL="next" HREF="lw-1258.htm" TYPE="text/html">
<LINK REL="prev" HREF="lw-1256.htm" TYPE="text/html">
<LINK REL="up" HREF="lw-1155.htm" TYPE="text/html">
<LINK REL="top" HREF="lw.htm" TYPE="text/html">
<LINK REL="contents" HREF="lw-2.htm" TYPE="text/html">
<LINK REL="index" HREF="lw-1525.htm" TYPE="text/html">
</HEAD>
<BODY BGCOLOR="#ffffff">
<DIV CLASS="HTMLBreadCrumbs"><A HREF="../../intro.htm">All Manuals</A> &gt; <A HREF="lw.htm">LispWorks User Guide and Reference Manual</A> &gt; <A HREF="lw-1155.htm">38 The SQL Package</A><BR><BR>
</DIV><A HREF="lw-1258.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A><A HREF="lw-1256.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Prev BORDER=0></A><A HREF="lw-1155.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A><A HREF="lw.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A><A HREF="lw-2.htm"><IMG ALIGN=BOTTOM SRC=contents.gif ALT=Contents BORDER=0></A><A HREF="lw-1525.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A>
<H4 CLASS="REntry">
<A NAME="pgfId-889287"></A><A NAME="30104"></A>select<A NAME="marker-1047663"></A></H4>
<DIV>
<H5 CLASS="REntry-type">
<A NAME="pgfId-889288"></A>Function</H5>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-889289"></A>Summary</H5>
<P CLASS="RBody">
<A NAME="pgfId-889290"></A>Selects data from a database given a number of specified constraints.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-889291"></A>Package</H5>
<P CLASS="RSignature">
<A NAME="pgfId-889292"></A>sql</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-889293"></A>Signature</H5>
<P CLASS="RSignature">
<A NAME="pgfId-889294"></A>select &amp;rest <EM CLASS="Variable">
selections</EM>
 &amp;key <EM CLASS="Variable">
all</EM>
 <EM CLASS="Variable">
set-operation</EM>
 <EM CLASS="Variable">
distinct</EM>
 <EM CLASS="Variable">
from</EM>
 <EM CLASS="Variable">
result-types</EM>
 <EM CLASS="Variable">
flatp</EM>
 <EM CLASS="Variable">
where</EM>
 <EM CLASS="Variable">
group-by</EM>
 <EM CLASS="Variable">
having</EM>
 <EM CLASS="Variable">
database</EM>
 <EM CLASS="Variable">
order-by</EM>
 <EM CLASS="Variable">
refresh</EM>
 <EM CLASS="Variable">
for-update</EM>
 =&gt; <EM CLASS="Variable">
result-list</EM>
</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-889295"></A>Arguments</H5>
<P CLASS="RDescription-Item">
<A NAME="pgfId-889296"></A><EM CLASS="Variable">
selections</P>
<P CLASS="RDescription-C"></EM>
A set of database identifiers or strings or a prepared-statement.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-889297"></A><EM CLASS="Variable">
all</P>
<P CLASS="RDescription-C"></EM>
A boolean.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-889299"></A><EM CLASS="Variable">
set-operation</EM>
</P>
<P CLASS="RDescription-C">A SQL operation.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1005487"></A><EM CLASS="Variable">
distinct</EM>
</P>
<P CLASS="RDescription-C">A boolean.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-889301"></A><EM CLASS="Variable">
from</P>
<P CLASS="RDescription-C"></EM>
A SQL table.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1051966"></A><EM CLASS="Variable">
result-types</EM>
</P>
<P CLASS="RDescription-C">A list of symbols.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1005589"></A><EM CLASS="Variable">
flatp</P>
<P CLASS="RDescription-C"></EM>
A boolean.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-889302"></A><EM CLASS="Variable">
where</EM>
</P>
<P CLASS="RDescription-C">A SQL condition.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-889303"></A><EM CLASS="Variable">
group-by</P>
<P CLASS="RDescription-C"></EM>
A SQL condition.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-889304"></A><EM CLASS="Variable">
having</P>
<P CLASS="RDescription-C"></EM>
A SQL condition.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-889306"></A><EM CLASS="Variable">
database</EM>
</P>
<P CLASS="RDescription-C">A database.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1005715"></A><EM CLASS="Variable">
order-by</EM>
</P>
<P CLASS="RDescription-C">A SQL condition.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1005690"></A><EM CLASS="Variable">
refresh</EM>
</P>
<P CLASS="RDescription-C">A boolean.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-1062636"></A><EM CLASS="Variable">
for-update</EM>
</P>
<P CLASS="RDescription-C"><CODE CLASS="Code">
t</CODE>
, <CODE CLASS="Code">
:nowait</CODE>
, a string or a list.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-889307"></A>Values</H5>
<P CLASS="RDescription-Item">
<A NAME="pgfId-889308"></A><EM CLASS="Variable">
result-list</P>
<P CLASS="RDescription-C"></EM>
A list of selections.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-889309"></A>Description</H5>
<P CLASS="RBody">
<A NAME="pgfId-889310"></A>The function <CODE CLASS="Code">
select</CODE>
 selects data from <EM CLASS="Variable">
database</EM>
, which has a default value of <A HREF="lw-1169.htm#92691" CLASS="XRef">*default-database*</A>, given the constraints specified by the rest of the arguments. It returns a list of objects as specified by <EM CLASS="Variable">
selections</EM>
. By default, the objects will each be represented as lists of attribute values. </P>
<P CLASS="RBody">
<A NAME="pgfId-1021851"></A>The argument <EM CLASS="Variable">
selections</EM>
 consists either of database identifiers, type-modified database identifiers or literal strings.</P>
<P CLASS="RBody">
<A NAME="pgfId-1268103"></A>A type-modified database identifier is an expression such as <CODE CLASS="Code">
[foo :string]</CODE>
 which means that the values in column <CODE CLASS="Code">
foo</CODE>
 are returned as Lisp strings. This syntax can be used to force values in time/date fields to be returned as strings (see below for an example). It can also be used to affect the value returned from MySQL, using the keywords mentioned in the section <A HREF="lw-408.htm#32443" CLASS="XRef">Using MySQL</A>. It can also be used to return <A HREF="lw-1196.htm#28604" CLASS="XRef">lob-stream</A> objects for queries on Oracle LOB columns, using an expression like <CODE CLASS="Code">
[foo :input-stream]</CODE>
 or <CODE CLASS="Code">
[foo :output-stream]</CODE>
</P>
<P CLASS="RBody">
<A NAME="pgfId-1052009"></A><EM CLASS="Variable">
result-types</EM>
 is used when <EM CLASS="Variable">
selections</EM>
 is <CODE CLASS="Code">
*</CODE>
 or <CODE CLASS="Code">
[*]</CODE>
. It should be a list of symbols such as <CODE CLASS="Code">
:string</CODE>
 and <CODE CLASS="Code">
:integer</CODE>
, one for each field in the table being selected in order to specify the types to return. Note that, for specific selections, the result type can be specified by using a type-modified identifier as described above. However, you cannot use <EM CLASS="Variable">
result-types</EM>
 to modify the type returned from a time/date field.</P>
<P CLASS="RBody">
<A NAME="pgfId-889311"></A>The <EM CLASS="Variable">
flatp</EM>
 argument, which has a default value of <CODE CLASS="Code">
nil</CODE>
, specifies if full bracketed results should be returned for each matched entry. If <EM CLASS="Variable">
flatp</EM>
 is <CODE CLASS="Code">
nil</CODE>
, the results are returned as a list of lists. If <EM CLASS="Variable">
flatp</EM>
 is <CODE CLASS="Code">
t</CODE>
, the results are returned as elements of a list, only if there is only one result per row. See the examples section for an example of the use of <EM CLASS="Variable">
flatp</EM>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-889312"></A>The arguments <EM CLASS="Variable">
all</EM>
, <EM CLASS="Variable">
set-operation</EM>
, <EM CLASS="Variable">
distinct</EM>
, <EM CLASS="Variable">
from</EM>
, <EM CLASS="Variable">
where</EM>
, <EM CLASS="Variable">
group-by</EM>
, <EM CLASS="Variable">
having</EM>
 and <EM CLASS="Variable">
order-by</EM>
 have the same function as the equivalent SQL expression.</P>
<P CLASS="RBody">
<A NAME="pgfId-1062642"></A><EM CLASS="Variable">
for-update</EM>
 is used to specify the FOR UPDATE clause in a select statement which is used by Oracle to lock the selected records. If <EM CLASS="Variable">
for-update</EM>
 is <CODE CLASS="Code">
t</CODE>
 then a plain &quot;FOR UPDATE&quot; clause is generated. This locks all retrieved records, waiting for the locks to become available. If <EM CLASS="Variable">
for-update</EM>
 is <CODE CLASS="Code">
:nowait</CODE>
 then a &quot;FOR UPDATE NOWAIT&quot; clause is generated. This locks all the retrieved records, or otherwise returns with error ora-00054 which causes Lisp to signal a <A HREF="lw-1273.htm#94734" CLASS="XRef">sql-temporary-error</A>. If <EM CLASS="Variable">
for-update</EM>
 is a string then it should specify a column to be locked and a clause &quot;FOR UPDATE OF <EM CLASS="Variable">
for-update</EM>
&quot; is generated. If <EM CLASS="Variable">
for-update</EM>
 is a list then the elements of the list should be strings each specifying a column to be locked, except that the last element of the list may be <CODE CLASS="Code">
:nowait</CODE>
. A clause locking multiple columns is generated, waiting for the locks according to whether <CODE CLASS="Code">
:nowait</CODE>
 was supplied. For an example see the section <A HREF="lw-430.htm#68143" CLASS="XRef">Locking</A>.</P>
<P CLASS="RBody">
<A NAME="pgfId-889313"></A>The function <CODE CLASS="Code">
select</CODE>
 is common across both the functional and object-oriented SQL interfaces. If <EM CLASS="Variable">
selections</EM>
 refers to View Classes then the select operation becomes object-oriented. This means that <CODE CLASS="Code">
select</CODE>
 returns a list of View Class instances, and <CODE CLASS="Code">
slot-value </CODE>
becomes a valid SQL operator for use within the <EM CLASS="Variable">
where</EM>
 clause. </P>
<P CLASS="RBody">
<A NAME="pgfId-1478496"></A>In the View Class case, a second equivalent <CODE CLASS="Code">
select</CODE>
 call will return the same View Class instance objects. If <EM CLASS="Variable">
refresh</EM>
 is true, then existing instances are updated if necessary, and in this case you might need to extend the hook <A HREF="lw-1190.htm#60214" CLASS="XRef">instance-refreshed</A>. Any join slots defined using <EM CLASS="Variable">
retrieval</EM>
 <CODE CLASS="Code">
:deferred</CODE>
  will be recomputed the next time time they are accessed. The default value of <EM CLASS="Variable">
refresh</EM>
 is <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-889314"></A>SQL expressions used in the <CODE CLASS="Code">
select</CODE>
 function are specified using the square bracket syntax, once this syntax has been enabled using <A HREF="lw-1184.htm#20888" CLASS="XRef">enable-sql-reader-syntax</A>.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-889318"></A>Examples</H5>
<P CLASS="RBody">
<A NAME="pgfId-889319"></A>The following is a potential query and result:</P>
<CODE CLASS="RCode-line">
<A NAME="pgfId-889320"></A>(select [person_id] [surname] :from [person])</CODE>
<CODE CLASS="RCode-line">
<A NAME="pgfId-889321"></A>=&gt; ((111 &quot;Brown&quot;) (112 &quot;Jones&quot;) (113 &quot;Smith&quot;))</CODE>
<P CLASS="RBody">
<A NAME="pgfId-889322"></A>In the next example, the <EM CLASS="Variable">
flatp</EM>
 argument is set to <CODE CLASS="Code">
t</CODE>
, and the result is a simple list of surname values:</P>
<CODE CLASS="RCode-line">
<A NAME="pgfId-889323"></A>(select [surname] :from [person] :flatp t)</CODE>
<CODE CLASS="RCode-line">
<A NAME="pgfId-889324"></A>=&gt; (&quot;Brown&quot; &quot;Jones&quot; &quot;Smith&quot;)</CODE>
<P CLASS="RBody">
<A NAME="pgfId-1022090"></A>In this example data in the attribute <CODE CLASS="Code">
largenum</CODE>
, which is of a vendor-specific large numeric type, is returned to Lisp as strings: </P>
<CODE CLASS="RCode-line">
<A NAME="pgfId-1022123"></A>(sql:select [largenum :string] :from [my-table])</CODE>
<P CLASS="RBody">
<A NAME="pgfId-1052223"></A>In this example the second column of <CODE CLASS="Code">
some_table</CODE>
 is a date that we want to return as a string:</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-1052305"></A>(sql:select [*]</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1052306"></A>            :from [some_table]</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-1052240"></A>            :result-types '(nil :string))</PRE>
<P CLASS="RBody">
<A NAME="pgfId-1058533"></A>In this example we see that a time/date field value is returned as an integer. We then use Common Lisp to decode that universal time, and finally query the database again, forcing the return value to be a string formatted by the database:</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-1059198"></A>CL-USER 219 &gt; (sql:select [MyDate] </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059199"></A>                          :from [MyTable] </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059200"></A>                          :flatp t)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059201"></A>(3313785600)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059202"></A>(&quot;MYDATE&quot;)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059203"></A>&nbsp;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059204"></A>CL-USER 220 &gt; (decode-universal-time (car *))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059205"></A>0</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059206"></A>0</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059207"></A>0</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059208"></A>4</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059209"></A>1</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059210"></A>2005</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059211"></A>1</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059212"></A>NIL</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059213"></A>0</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059214"></A>&nbsp;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059215"></A>CL-USER 221 &gt; (sql:select [MyDate :string] </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059216"></A>                          :from [MyTable] </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1059217"></A>                          :flatp t)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1269299"></A>(&quot;2005-01-04 00:00:00&quot;)</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-1269300"></A>(&quot;MYDATE&quot;)</PRE>
<P CLASS="RBody">
<A NAME="pgfId-1269301"></A>Finally this code gets the first 1KB of data from the first LOB returned by a query on an Oracle table containing a column of type LOB:</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-1269890"></A>(let* ((array </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1269891"></A>        (make-array 1024</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1269892"></A>                    :element-type '(unsigned-byte 8)))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1269893"></A>       (lobs (sql:select [my-lob-column :input-stream] </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-1269894"></A>                         :from [mytable] :flatp t)))</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-1268130"></A>  (read-sequence array (car lobs)))</PRE>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-889325"></A>See also</H5>
<P CLASS="RBody">
<A NAME="pgfId-889329"></A><A HREF="lw-1190.htm#60214" CLASS="XRef">instance-refreshed</A><BR>
<A HREF="lw-1196.htm#28604" CLASS="XRef">lob-stream</A><BR>
<A HREF="lw-1251.htm#97309" CLASS="XRef">prepare-statement</A><BR>
<A HREF="lw-1252.htm#19259" CLASS="XRef">print-query</A></P>
</DIV>
<HR>
<P CLASS="Copyrighttext-small"><I CLASS="Italic">LispWorks User Guide and Reference Manual - 21 Dec 2011</I></P>
<P><A HREF="lw-1258.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A><A HREF="lw-1256.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Prev BORDER=0></A><A HREF="lw-1155.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A><A HREF="lw.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A><A HREF="lw-2.htm"><IMG ALIGN=BOTTOM SRC=contents.gif ALT=Contents BORDER=0></A><A HREF="lw-1525.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A>
</BODY>
</HTML>
