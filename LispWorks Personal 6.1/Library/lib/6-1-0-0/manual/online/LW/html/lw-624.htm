<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="lw.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
 start-up-server
</TITLE>

<LINK REL="next" HREF="lw-625.htm" TYPE="text/html">
<LINK REL="prev" HREF="lw-623.htm" TYPE="text/html">
<LINK REL="up" HREF="lw-579.htm" TYPE="text/html">
<LINK REL="top" HREF="lw.htm" TYPE="text/html">
<LINK REL="contents" HREF="lw-2.htm" TYPE="text/html">
<LINK REL="index" HREF="lw-1525.htm" TYPE="text/html">
</HEAD>
<BODY BGCOLOR="#ffffff">
<DIV CLASS="HTMLBreadCrumbs"><A HREF="../../intro.htm">All Manuals</A> &gt; <A HREF="lw.htm">LispWorks User Guide and Reference Manual</A> &gt; <A HREF="lw-579.htm">26 The COMM Package</A><BR><BR>
</DIV><A HREF="lw-625.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A><A HREF="lw-623.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Prev BORDER=0></A><A HREF="lw-579.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A><A HREF="lw.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A><A HREF="lw-2.htm"><IMG ALIGN=BOTTOM SRC=contents.gif ALT=Contents BORDER=0></A><A HREF="lw-1525.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A>
<H4 CLASS="REntry">
<A NAME="pgfId-888403"></A><A NAME="14172"></A>start<A NAME="marker-910861"></A>-up-server</H4>
<DIV>
<H5 CLASS="REntry-type">
<A NAME="pgfId-888404"></A>Function</H5>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-888407"></A>Summary</H5>
<P CLASS="RBody">
<A NAME="pgfId-888409"></A>Starts a TCP server.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-888411"></A>Package</H5>
<P CLASS="RSignature">
<A NAME="pgfId-888413"></A>comm</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-888415"></A>Signature</H5>
<P CLASS="RSignature">
<A NAME="pgfId-903328"></A>start-up-server &amp;key <EM CLASS="Variable">
function</EM>
 <EM CLASS="Variable">
announce</EM>
 <EM CLASS="Variable">
service</EM>
 <EM CLASS="Variable">
address</EM>
 <EM CLASS="Variable">
nodelay</EM>
 <EM CLASS="Variable">
keepalive</EM>
 <EM CLASS="Variable">
process-name</EM>
 <EM CLASS="Variable">
wait</EM>
 <EM CLASS="Variable">
error</EM>
 =&gt; <EM CLASS="Variable">
process</EM>
, <EM CLASS="Variable">
startup-condition</EM>
</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-903329"></A>Arguments</H5>
<P CLASS="RDescription-Item">
<A NAME="pgfId-888421"></A><EM CLASS="Variable">
function</P>
<P CLASS="RDescription-C"></EM>
A function name.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-888423"></A><EM CLASS="Variable">
announce</EM>
</P>
<P CLASS="RDescription-C">An output stream, <CODE CLASS="Code">
t</CODE>
, <CODE CLASS="Code">
nil</CODE>
 or a function.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-909139"></A><EM CLASS="Variable">
service</P>
<P CLASS="RDescription-C"></EM>
An integer, a string or <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-909143"></A><EM CLASS="Variable">
address</P>
<P CLASS="RDescription-C"></EM>
An integer, an <A HREF="lw-592.htm#44856" CLASS="XRef">ipv6-address</A> object, a string or <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-946639"></A><EM CLASS="Variable">
nodelay</EM>
</P>
<P CLASS="RDescription-C">A generalized boolean.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-946640"></A><EM CLASS="Variable">
keepalive</EM>
</P>
<P CLASS="RDescription-C">A generalized boolean.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-888431"></A><EM CLASS="Variable">
process-name</P>
<P CLASS="RDescription-C"></EM>
A symbol or expression.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-903384"></A><EM CLASS="Variable">
wait</EM>
</P>
<P CLASS="RDescription-C">A boolean.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-996973"></A><EM CLASS="Variable">
ipv6</EM>
</P>
<P CLASS="RDescription-C">The keyword <CODE CLASS="Code">
:any</CODE>
, <CODE CLASS="Code">
nil</CODE>
 or <CODE CLASS="Code">
t</CODE>
.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-903528"></A><EM CLASS="Variable">
error</EM>
</P>
<P CLASS="RDescription-C">A boolean.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-903385"></A>Values</H5>
<P CLASS="RDescription-Item">
<A NAME="pgfId-888434"></A><EM CLASS="Variable">
process</EM>
</P>
<P CLASS="RDescription-C">A process, or <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RDescription-Item">
<A NAME="pgfId-903340"></A><EM CLASS="Variable">
startup-condition</EM>
</P>
<P CLASS="RDescription-C">A condition object, or <CODE CLASS="Code">
nil</CODE>
.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-888436"></A>Description</H5>
<P CLASS="RBody">
<A NAME="pgfId-888438"></A>The function <CODE CLASS="Code">
start-up-server</CODE>
 starts a TCP server. Use <A HREF="lw-597.htm#15026" CLASS="XRef">open-tcp-stream</A> to send messages from another client to the server.</P>
<P CLASS="RBody">
<A NAME="pgfId-888454"></A>The <EM CLASS="Variable">
function</EM>
 argument provides the name of the function that processes connections. When a connection is made <EM CLASS="Variable">
function</EM>
 is called with the connected socket handle, at which point you can make a stream using <A HREF="lw-655.htm#39152" CLASS="XRef">make-instance</A> and communicate with the client. The server does not accept more connections until <EM CLASS="Variable">
function</EM>
 returns, so normally it should create another light-weight process to handle the connection. However, the operating system typically provides a small queue of partially accepted connections, which prevents connection failure for new clients until the server is ready to accept more connections. If  <EM CLASS="Variable">
function</EM>
 is not specified the built-in Lisp listener server is used. See the examples section below.</P>
<P CLASS="RBody">
<A NAME="pgfId-888872"></A>If <EM CLASS="Variable">
announce</EM>
 is a stream or <CODE CLASS="Code">
t</CODE>
 (denoting <CODE CLASS="Code">
*standard-output*</CODE>
), a message appears on the stream when the server is started. </P>
<P CLASS="RBody">
<A NAME="pgfId-904713"></A>If <EM CLASS="Variable">
announce</EM>
 is a function it is called when the server is started. <EM CLASS="Variable">
announce</EM>
 should take two arguments: <EM CLASS="Variable">
socket</EM>
 and <EM CLASS="Variable">
condition</EM>
. <EM CLASS="Variable">
socket</EM>
 is the socket used by the server: <EM CLASS="Variable">
announce</EM>
 can therefore be used to record this socket. <EM CLASS="Variable">
condition</EM>
 describes the error if there is one. <EM CLASS="Variable">
announce</EM>
 can be called with <EM CLASS="Variable">
socket</EM>
 <CODE CLASS="Code">
nil</CODE>
 and a condition only if <EM CLASS="Variable">
error</EM>
 is <CODE CLASS="Code">
nil</CODE>
. If the process is killed, <EM CLASS="Variable">
announce</EM>
 is called with <EM CLASS="Variable">
socket</EM>
 <CODE CLASS="Code">
nil</CODE>
 and <EM CLASS="Variable">
condition</EM>
 <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-904714"></A>The default for <EM CLASS="Variable">
announce</EM>
 is <CODE CLASS="Code">
nil</CODE>
, meaning there is no message. </P>
<P CLASS="RBody">
<A NAME="pgfId-888683"></A>If <EM CLASS="Variable">
service</EM>
 is a string or positive integer, it specifies the name of the service. The location of the file specifying the names of services available varies, but typically on Windows 98 it is called <CODE CLASS="Code">
SERVICES</CODE>
 and is stored in the <CODE CLASS="Code">
Windows</CODE>
 directory, and on Windows NT-based systems it is the file </P>
<CODE CLASS="RCode-line">
<A NAME="pgfId-903666"></A>%SystemRoot%&#92;system32&#92;drivers&#92;etc&#92;SERVICES</CODE>
<P CLASS="RBody">
<A NAME="pgfId-903667"></A>If <EM CLASS="Variable">
service</EM>
 is <CODE CLASS="Code">
nil</CODE>
 or 0, then <CODE CLASS="Code">
start-up-server</CODE>
 chooses a free port. The default value for <EM CLASS="Variable">
service</EM>
 is &quot;<CODE CLASS="Code">
lispworks</CODE>
&quot;.</P>
<P CLASS="RBody">
<A NAME="pgfId-909201"></A>If <EM CLASS="Variable">
address</EM>
 is a string or an <A HREF="lw-592.htm#44856" CLASS="XRef">ipv6-address</A> object or an integer that can be resolved to an IP address, then the server only receives connections for that IP address. This must be one of the addresses associated with the machine and allowed values are a string naming a host, such as <CODE CLASS="Code">
&quot;www.nowhere.com&quot;</CODE>
, a string providing the IP address, such as <CODE CLASS="Code">
&quot;204.71.177.75&quot;</CODE>
, or and integer IP address in network order, such as <CODE CLASS="Code">
#xCC47B14B</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-996863"></A>If <EM CLASS="Variable">
address</EM>
 is <CODE CLASS="Code">
nil</CODE>
 or 0, then the server will receive connections to all IP addresses on the machine.  This is the default.</P>
<P CLASS="RBody">
<A NAME="pgfId-996869"></A><EM CLASS="Variable">
address</EM>
 also determines which family is used when making the socket. <CODE CLASS="Code">
AF_INET6</CODE>
 is used in these cases:</P>
<UL>
<LI CLASS="RBullet">
<A NAME="pgfId-996920"></A>The address is an <A HREF="lw-592.htm#44856" CLASS="XRef">ipv6-address</A>.</LI>
<LI CLASS="RBullet">
<A NAME="pgfId-996923"></A>The address is a string specifying an IPv6 address.</LI>
<LI CLASS="RBullet">
<A NAME="pgfId-996926"></A>The address is a string that resolves to an IPv6 address.</LI>
</UL>
<P CLASS="RBody">
<A NAME="pgfId-996952"></A>Otherwise <CODE CLASS="Code">
AF_INET</CODE>
 is used. When <EM CLASS="Variable">
address</EM>
 is not supplied, <CODE CLASS="Code">
AF_INET</CODE>
 is used. To open a server with <CODE CLASS="Code">
AF_INET6</CODE>
 listening to any address, either use the keyword argument <EM CLASS="Variable">
ipv6</EM>
 or pass the zero IPv6 address <CODE CLASS="Code">
&quot;::&quot;</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-996865"></A>If <EM CLASS="Variable">
keepalive</EM>
 is true, SO_KEEPALIVE is set on the socket. The default value of <EM CLASS="Variable">
keepalive</EM>
 is <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-946648"></A>If <EM CLASS="Variable">
nodelay</EM>
 is true, TCP_NODELAY is set on the socket. The default value of <EM CLASS="Variable">
nodelay</EM>
 is <CODE CLASS="Code">
t</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-888456"></A>The <EM CLASS="Variable">
process-name</EM>
 specifies the process name. The default is constructed from the service name in the following fashion:</P>
<CODE CLASS="RCode-line">
<A NAME="pgfId-888457"></A>(format nil &quot;&#126;S server&quot; service)</CODE>
<P CLASS="RBody">
<A NAME="pgfId-903398"></A>The <EM CLASS="Variable">
wait</EM>
 argument controls whether <CODE CLASS="Code">
start-up-server</CODE>
 waits for the server to start or returns immediately. When <EM CLASS="Variable">
wait</EM>
 is non-<CODE CLASS="Code">
nil</CODE>
 and an error was signalled, <EM CLASS="Variable">
process</EM>
 is <CODE CLASS="Code">
nil</CODE>
 and the error is returned in <EM CLASS="Variable">
startup-condition</EM>
  Otherwise just one value, the server process, is returned. The default for <EM CLASS="Variable">
wait</EM>
 is <CODE CLASS="Code">
nil</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-997061"></A><EM CLASS="Variable">
ipv6</EM>
 affects the resolution of <EM CLASS="Variable">
address</EM>
 if it is a string or <CODE CLASS="Code">
nil</CODE>
. When <EM CLASS="Variable">
ipv6</EM>
 is is <CODE CLASS="Code">
nil</CODE>
, it forces IPv4 addresses, and if <EM CLASS="Variable">
ipv6</EM>
 is <CODE CLASS="Code">
t</CODE>
 it forces IPv6 addresses. The value <CODE CLASS="Code">
:any</CODE>
 has no effect. The default value of <EM CLASS="Variable">
ipv6</EM>
 is <CODE CLASS="Code">
:any</CODE>
.</P>
<P CLASS="RBody">
<A NAME="pgfId-903472"></A>The <EM CLASS="Variable">
error</EM>
 argument controls what happens if an error is signalled in the server thread. If <EM CLASS="Variable">
error</EM>
 is <CODE CLASS="Code">
nil</CODE>
 then the thread is terminated. If <EM CLASS="Variable">
error</EM>
 is non-nil then the debugger is entered. The default value for error is <CODE CLASS="Code">
(not</CODE>
 <EM CLASS="Variable">
wait</EM>
<CODE CLASS="Code">
)</CODE>
.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-903495"></A>Notes</H5>
<P CLASS="RBody">
<A NAME="pgfId-997068"></A>Some versions of Microsoft Windows fail to detect the case where more than one server binds a given port, so an error will not be raised in this situation.</P>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-888696"></A>Examples</H5>
<P CLASS="RBody">
<A NAME="pgfId-888701"></A>The following example uses the built-in Lisp listener server:</P>
<CODE CLASS="RCode-line">
<A NAME="pgfId-888710"></A>(comm:start-up-server :service 10243)</CODE>
<P CLASS="RBody">
<A NAME="pgfId-888702"></A>It makes a Lisp listener server on port 10243 (check with local network managers that this port number is safe to use). When a client connects to this, Lisp calls <CODE CLASS="Code">
read</CODE>
. The client should send a string using Common Lisp syntax followed by a newline. This string is used to name a new light-weight process that runs a Lisp listener. When this has been created, the server waits for more connections.</P>
<P CLASS="RBody">
<A NAME="pgfId-888892"></A>The next example illustrates the use of the <EM CLASS="Variable">
function</EM>
 argument. For each line of input read by the server it writes the line back with a message. The stream generates <CODE CLASS="Code">
EOF</CODE>
 if the other end closes the connection.</P>
<CODE CLASS="RCode-line">
<A NAME="pgfId-888896"></A>(defvar *talk-port* 10244)  ; a free TCP port number</CODE>
<PRE CLASS="RCode-first"><A NAME="pgfId-888897"></A>(defun make-stream-and-talk (handle)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888904"></A>  (let ((stream (make-instance 'comm:socket-stream</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888905"></A>                               :socket handle</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888906"></A>                               :direction :io</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888907"></A>                               :element-type</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888908"></A>                                  'base-char)))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888909"></A>  (mp:process-run-function (format nil &quot;talk &#126;D&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888910"></A>                                   handle)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888911"></A>                           '()</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-888912"></A>                           'talk-on-stream stream)))</PRE>
<PRE CLASS="RCode-first"><A NAME="pgfId-888913"></A>(defun talk-on-stream (stream)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888914"></A>  (unwind-protect</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888915"></A>      (loop for line = (read-line stream nil nil)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888916"></A>            while line</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888917"></A>            do</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888918"></A>            (format stream &quot;You sent: '&#126;A'&#126;%&quot; line)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-888919"></A>            (force-output stream))</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-888920"></A>      (close stream)))</PRE>
<PRE CLASS="RCode-first"><A NAME="pgfId-888921"></A>(comm:start-up-server :function 'make-stream-and-talk</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-888930"></A>                      :service *talk-port*)</PRE>
<P CLASS="RBody">
<A NAME="pgfId-896242"></A>This is a client which uses the talk server:</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-896512"></A>(defun talking-to-myself ()</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896513"></A>  (with-open-stream </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896675"></A>      (talk (comm:open-tcp-stream &quot;localhost&quot; </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896515"></A>                                  *talk-port*))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896679"></A>    (dolist (monolog </PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896516"></A>             '(&quot;Hello self.&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896517"></A>               &quot;Why don't you say something original?&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896518"></A>               &quot;Talk to you later then.  Bye.&quot;))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896519"></A>      (write-line monolog talk)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896520"></A>      (force-output talk)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896521"></A>      (format t &quot;I said: &#92;&quot;&#126;A&#92;&quot;&#126;%&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896522"></A>              monolog)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896523"></A>      (format t &quot;Self replied: &#92;&quot;&#126;A&#92;&quot;&#126;%&quot;</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-896723"></A>              (read-line talk nil nil)))))</PRE>
<PRE CLASS="RCode-first"><A NAME="pgfId-896749"></A>(talking-to-myself)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896810"></A>=&gt;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896750"></A>I said: &quot;Hello self.&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896751"></A>Self replied: &quot;You sent: 'Hello self.'&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896752"></A>I said: &quot;Why don't you say something original?&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896753"></A>Self replied: &quot;You sent: 'Why don't you say something original?'&quot;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-896754"></A>I said: &quot;Talk to you later then.  Bye.&quot;</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-896724"></A>Self replied: &quot;You sent: 'Talk to you later then.  Bye.'&quot;</PRE>
<P CLASS="RBody">
<A NAME="pgfId-904462"></A>This example illustrates a server which picks a free port and records the socket. The last form queries the socket for the port used.</P>
<PRE CLASS="RCode-first"><A NAME="pgfId-904463"></A>(defvar *my-socket* nil)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904464"></A>&nbsp;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904465"></A>(defun my-announce-function (socket condition)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904466"></A>  (if socket</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904467"></A>      (setf *my-socket* socket)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904468"></A>    (my-log-error condition)))</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904469"></A>&nbsp;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904470"></A>(comm:start-up-server :service nil</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904471"></A>                      :error nil</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904472"></A>                      :announce 'my-announce-function)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904657"></A>&nbsp;</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904633"></A>(multiple-value-bind (address port)</PRE>
<PRE CLASS="RCode-body"><A NAME="pgfId-904634"></A>    (comm:get-socket-address *my-socket*)</PRE>
<PRE CLASS="RCode-last"><A NAME="pgfId-904473"></A>  port)</PRE>
</DIV>
<DIV>
<H5 CLASS="REntry-head">
<A NAME="pgfId-896725"></A>See also</H5>
<P CLASS="RBody">
<A NAME="pgfId-888442"></A><A HREF="lw-597.htm#15026" CLASS="XRef">open-tcp-stream</A><BR>
<A HREF="lw-602.htm#50444" CLASS="XRef">server-terminate</A><BR>
<A HREF="lw-609.htm#32260" CLASS="XRef">socket-stream</A></P>
</DIV>
<HR>
<P CLASS="Copyrighttext-small"><I CLASS="Italic">LispWorks User Guide and Reference Manual - 21 Dec 2011</I></P>
<P><A HREF="lw-625.htm"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A><A HREF="lw-623.htm"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Prev BORDER=0></A><A HREF="lw-579.htm"><IMG ALIGN=BOTTOM SRC=up.gif ALT=Up BORDER=0></A><A HREF="lw.htm"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A><A HREF="lw-2.htm"><IMG ALIGN=BOTTOM SRC=contents.gif ALT=Contents BORDER=0></A><A HREF="lw-1525.htm"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A>
</BODY>
</HTML>
